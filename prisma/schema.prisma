// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String          @id @default(uuid())
  email          String          @unique
  name           String
  password       String
  // roles          Role[]          @relation("UserRoles") // Implicit relation removed
  userRoles      UserRole[]      // Relation to the explicit join table
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  warehouses     Warehouse[]     @relation("WarehouseManagers")
  transactions   Transaction[]   @relation("TransactionCreator")
  products       Product[]       @relation("ProductCreator")
}



model Product {
  id             String          @id @default(uuid())
  name           String
  description    String?
  sku            String          @unique
  price          Float
  cost           Float
  minStockLevel  Int             @default(0)
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  createdBy      User            @relation("ProductCreator", fields: [createdById], references: [id])
  createdById    String
  category       Category?       @relation(fields: [categoryId], references: [id])
  categoryId     String?
  inventories    Inventory[]
  transactionItems TransactionItem[]
}

model Category {
  id             String          @id @default(uuid())
  name           String          @unique
  description    String?
  products       Product[]
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
}

model Warehouse {
  id             String          @id @default(uuid())
  name           String
  location       String
  description    String?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  managers       User[]          @relation("WarehouseManagers")
  areas          Area[]          // Relation to Area
  transactions   Transaction[]   @relation("WarehouseTransactions")
  inventoryItems Inventory[]     @relation("WarehouseInventory") // Added back for relation
  shelves        Shelf[]         @relation("WarehouseShelves")   // Relation to Shelf
}

model Area {
  id             String          @id @default(uuid())
  name           String
  description    String?
  warehouse      Warehouse       @relation(fields: [warehouseId], references: [id])
  warehouseId    String
  shelves        Shelf[]         // Relation to Shelf
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  @@unique([name, warehouseId]) // Ensure area names are unique within a warehouse
}

model Shelf {
  id             String          @id @default(uuid())
  name           String
  position       String?         // e.g., "Row 1, Column 3"
  capacity       Int?            // Optional capacity limit
  status         String          @default("Aktif") // e.g., Aktif, Nonaktif
  area           Area            @relation(fields: [areaId], references: [id])
  areaId         String
  warehouse      Warehouse       @relation("WarehouseShelves", fields: [warehouseId], references: [id]) // Named relation
  warehouseId    String
  inventoryItems Inventory[]     // Stock items on this shelf
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  @@unique([name, areaId]) // Ensure shelf names are unique within an area
}

model Inventory {
  id             String          @id @default(uuid())
  quantity       Int
  product        Product         @relation(fields: [productId], references: [id])
  productId      String
  shelf          Shelf           @relation(fields: [shelfId], references: [id]) // Link inventory to a specific shelf
  shelfId        String
  warehouseId    String          // Keep warehouseId for potential direct queries/filtering
  warehouse      Warehouse       @relation("WarehouseInventory", fields: [warehouseId], references: [id]) // Named relation
  lastUpdated    DateTime        @updatedAt

  @@unique([productId, shelfId]) // Each product should have one inventory record per shelf
}

model Transaction {
  id             String          @id @default(uuid())
  type           TransactionType
  status         TransactionStatus @default(PENDING)
  date           DateTime        @default(now())
  notes          String?
  createdBy      User            @relation("TransactionCreator", fields: [createdById], references: [id])
  createdById    String
  warehouse      Warehouse       @relation("WarehouseTransactions", fields: [warehouseId], references: [id])
  warehouseId    String
  items          TransactionItem[]
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
}

model TransactionItem {
  id             String          @id @default(uuid())
  quantity       Int
  price          Float
  product        Product         @relation(fields: [productId], references: [id])
  productId      String
  transaction    Transaction     @relation(fields: [transactionId], references: [id])
  transactionId  String
}

enum TransactionType {
  PURCHASE
  SALE
  TRANSFER
  ADJUSTMENT
}

enum TransactionStatus {
  PENDING
  COMPLETED
  CANCELLED
}

// New models for Role-Based Access Control (RBAC)
model Role {
  id          String       @id @default(uuid())
  name        String       @unique
  description String?
  // users       User[]       @relation("UserRoles") // Implicit relation removed
  userRoles   UserRole[]   // Relation to the explicit join table
  permissions Permission[] @relation("RolePermissions")
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
}

// Explicit join table for User and Role (Many-to-Many)
model UserRole {
  userId String
  roleId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  role   Role   @relation(fields: [roleId], references: [id], onDelete: Cascade)
  assignedAt DateTime @default(now())
  assignedBy String? // Optional: track who assigned the role

  @@id([userId, roleId]) // Composite primary key
}

model Permission {
  id          String   @id @default(uuid())
  name        String   @unique // e.g., manage_inventory, view_reports, manage_users
  description String?
  roles       Role[]   @relation("RolePermissions")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}